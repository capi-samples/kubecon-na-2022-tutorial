"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[284],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=s(n),d=a,k=m["".concat(c,".").concat(d)]||m[d]||u[d]||l;return n?r.createElement(k,o(o({ref:t},p),{},{components:n})):r.createElement(k,o({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4155:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const l={},o="Implementing the cluster controller",i={unversionedId:"cluster-implementation",id:"cluster-implementation",title:"Implementing the cluster controller",description:"Objective: Define the DockerCluster API and implement the corresponding reconciliation logic.",source:"@site/docs/5-cluster-implementation.md",sourceDirName:".",slug:"/cluster-implementation",permalink:"/kubecon-na-2022-tutorial/docs/cluster-implementation",draft:!1,editUrl:"https://github.com/capi-samples/kubecon-na-2022-tutorial/docs/5-cluster-implementation.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Setting up Tilt",permalink:"/kubecon-na-2022-tutorial/docs/setup-tilt"},next:{title:"Implementing the machine controller",permalink:"/kubecon-na-2022-tutorial/docs/machine-implementation"}},c={},s=[{value:"Background",id:"background",level:2},{value:"Define <code>DockerCluster</code> API",id:"define-dockercluster-api",level:2},{value:"Implementing Reconciliation",id:"implementing-reconciliation",level:2},{value:"Implement Reconcile Pattern",id:"implement-reconcile-pattern",level:3},{value:"Implement create/update reconciliation",id:"implement-createupdate-reconciliation",level:3},{value:"Implement delete reconciliation",id:"implement-delete-reconciliation",level:3},{value:"Setup the controller",id:"setup-the-controller",level:3}],p={toc:s};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"implementing-the-cluster-controller"},"Implementing the cluster controller"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Objective:")," Define the ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," API and implement the corresponding reconciliation logic."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#implementing-the-cluster-apicontroller"},"Implementing the cluster api/controller"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#define-dockercluster-api"},"Define ",(0,a.kt)("inlineCode",{parentName:"a"},"DockerCluster")," API")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#implementing-reconciliation"},"Implementing Reconciliation"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#implement-reconcile-pattern"},"Implement Reconcile Pattern")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#implement-createupdate-reconciliation"},"Implement create/update reconciliation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#implement-delete-reconciliation"},"Implement delete reconciliation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#setup-the-controller"},"Setup the controller"))))))),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"When designing the ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," API kind we need to make sure that we adhere to the contract for a ",(0,a.kt)("a",{parentName:"p",href:"https://cluster-api.sigs.k8s.io/developer/providers/cluster-infrastructure.html"},"Cluster Infrastructure Provider")," and expose enough information to the user so that we can create any required infrastructure for the cluster (but not machines for nodes)."),(0,a.kt)("p",null,"In our example, the infrastructure that we need to provision is a load balancer to sit in front of our the API servers of our control plane nodes (that will be provisioned later). To do this, we will create an instance of an HAProxy container. The address of the load balancer will be specified in ",(0,a.kt)("inlineCode",{parentName:"p"},"controlPlaneEndPoint"),"."),(0,a.kt)("p",null,"When implementing the controller for ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," (and ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerMachine"),") you will generally follow a pattern similar to this:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"In ",(0,a.kt)("strong",{parentName:"li"},"Reconcile"),", get the instance of the API type being reconciled"),(0,a.kt)("li",{parentName:"ol"},"Get the owning CAPI type (i.e. if we are reconciling ",(0,a.kt)("inlineCode",{parentName:"li"},"DockerCluster")," then we get ",(0,a.kt)("inlineCode",{parentName:"li"},"Cluster"),")",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"You may need other types if you are reconciling machines"))),(0,a.kt)("li",{parentName:"ol"},"If the owning CAPI type doesn't exist yet (because the \"owner reference isn't set yet\"), then exit"),(0,a.kt)("li",{parentName:"ol"},"If the instance has a non-zero deletion timestamp (indicating that it has been marked for deletion), then call a ",(0,a.kt)("strong",{parentName:"li"},"reconcileDelete")," function that:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Performs any actions to delete the infrastructure"),(0,a.kt)("li",{parentName:"ol"},"Removes the finalizer and saves/patches"))),(0,a.kt)("li",{parentName:"ol"},"If the instance has a zero deletion timestamp (indicating that it is not being deleted), then call a ",(0,a.kt)("strong",{parentName:"li"},"reconcileNormal")," function that:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Adds a finalizer and saves/patches"),(0,a.kt)("li",{parentName:"ol"},"Performs any actions to create or update the infrastructure")))),(0,a.kt)("h2",{id:"define-dockercluster-api"},"Define ",(0,a.kt)("inlineCode",{parentName:"h2"},"DockerCluster")," API"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Read the ",(0,a.kt)("a",{parentName:"li",href:"https://cluster-api.sigs.k8s.io/developer/providers/cluster-infrastructure.html"},"contract")," for a cluster infrastructure provider."),(0,a.kt)("li",{parentName:"ol"},"Open ",(0,a.kt)("inlineCode",{parentName:"li"},"api/v1alpha1/dockercluster_types.go")," in your favourite editor."),(0,a.kt)("li",{parentName:"ol"},"Add the required fields to satisfy the contract:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Add  this import ",(0,a.kt)("inlineCode",{parentName:"li"},'clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"')),(0,a.kt)("li",{parentName:"ol"},"Add a field for the control plane endpoint to ",(0,a.kt)("strong",{parentName:"li"},"DockerClusterSpec")," (and remove the generated ",(0,a.kt)("inlineCode",{parentName:"li"},"Foo string")," lines):")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.\n// +optional\nControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`\n')),(0,a.kt)("ol",{parentName:"li",start:3},(0,a.kt)("li",{parentName:"ol"},"Add a ",(0,a.kt)("strong",{parentName:"li"},"Ready")," field to ",(0,a.kt)("strong",{parentName:"li"},"DockerClusterStatus"),":")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Ready indicates that the cluster is ready.\n// +optional\n// +kubebuilder:default=falctrl.SetupSignalHandler()se\nReady bool `json:"ready"`\n'))),(0,a.kt)("li",{parentName:"ol"},"Now add the provider specific fields to the ",(0,a.kt)("strong",{parentName:"li"},"DockerClusterSpec"),". In our example we will allow the user to optionally override the image to use for the loadbalancer. Add the following:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// LoadBalancerImage allows you override the load balancer image. If not specified a\n// default image will be used.\n// +optional\nLoadBalancerImage string `json:"loadbalancerImage,omitempty"`\n'))),(0,a.kt)("li",{parentName:"ol"},"As we will be creating external infrastructure, we will need to use finalizers. So define a finalizer:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    const (\n        // ClusterFinalizer allows cleaning up resources associated with \n        // DockerCluster before removing it from the apiserver.\n        ClusterFinalizer = "dockercluster.infrastructure.cluster.x-k8s.io"\n    )\n')),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},"Finalizers are used to mark an object to prevent Kubernetes from deleting it until the finalizer is removed. This allows the controller to delete any external infrastructure such as a container instances before removing the object. You can read more about finalizers ",(0,a.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/"},"here")," and ",(0,a.kt)("a",{parentName:"p",href:"https://book.kubebuilder.io/reference/using-finalizers.html"},"here"),"."))),(0,a.kt)("li",{parentName:"ol"},"Update the generated code and manifests by running:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"make generate\nmake manifests\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Additional Notes:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Note the ",(0,a.kt)("inlineCode",{parentName:"li"},"+optional")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"+kubebuilder:default=false")," in the comments. These are special comments that enable you to add validation to your CRD fields (via OpenAPI schema). Its advisable to add validation where possible. The list of available validations can be seen ",(0,a.kt)("a",{parentName:"li",href:"https://book.kubebuilder.io/reference/markers/crd-validation.html"},"here"),"."),(0,a.kt)("li",{parentName:"ul"},"The contract has a number of optional fields related within ",(0,a.kt)("strong",{parentName:"li"},"status")," to report failures. It is advisable that you implement these in your own provider."),(0,a.kt)("li",{parentName:"ul"},"Although not part of the contract, historically providers have added conditions to the ",(0,a.kt)("strong",{parentName:"li"},"status"),". We will not be using conditions but if you want to learn more read ",(0,a.kt)("a",{parentName:"li",href:"https://maelvls.dev/kubernetes-conditions/"},"this"),".")),(0,a.kt)("h2",{id:"implementing-reconciliation"},"Implementing Reconciliation"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Background:")," In this section we will be implementing the reconciliation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster"),". The purpose of the ",(0,a.kt)("strong",{parentName:"p"},"infrastructure cluster")," is to create any required infrastructure for the cluster but not anything related to individual machines/nodes. In the case of the tutorial we will be implementing the pattern mentioned above and creating a load balancer container instance that will be used to load balance requests to the control plane nodes (when they are created)."),(0,a.kt)("h3",{id:"implement-reconcile-pattern"},"Implement Reconcile Pattern"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Add a reference to the packages we need. in your terminal run:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"go get github.com/capi-samples/cluster-api-provider-docker/pkg\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We will be reusing various packages from the reference implementation so that we can focus on the provider implementation and not on the specific internals of docker.")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"Open ",(0,a.kt)("inlineCode",{parentName:"li"},"controllers/dockercluster_controller.go")," in your editor. The rest of the steps in this section will relate to this file unless explicitly stated otherwise."),(0,a.kt)("li",{parentName:"ol"},"Change the signature of ",(0,a.kt)("strong",{parentName:"li"},"Reconcile")," to match:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func (r *DockerClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, rerr error) {\n")),(0,a.kt)("ol",{start:5},(0,a.kt)("li",{parentName:"ol"},"Our controller will need read RBAC permission for ",(0,a.kt)("strong",{parentName:"li"},"Cluster"),". So add the following to the comment for ",(0,a.kt)("strong",{parentName:"li"},"Reconcile"),":")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters;clusters/status,verbs=get;list;watch\n")),(0,a.kt)("ol",{start:6},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"We will be interacting with the container runtime, to support this:"),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Add ",(0,a.kt)("inlineCode",{parentName:"li"},'"github.com/capi-samples/cluster-api-provider-docker/pkg/container"')," as an import"),(0,a.kt)("li",{parentName:"ol"},"Add a field to the ",(0,a.kt)("strong",{parentName:"li"},"DockerClusterReconciler")," struct that holds a reference to the container runtime. The struct should now contain:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type DockerClusterReconciler struct {\n    client.Client\n    Scheme           *runtime.Scheme\n    ContainerRuntime container.Runtime\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"In the ",(0,a.kt)("strong",{parentName:"p"},"Reconcile")," make these changes:"),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"We will be creating log entries, so save the logger to a variable")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"logger := log.FromContext(ctx)\n")),(0,a.kt)("ol",{parentName:"li",start:2},(0,a.kt)("li",{parentName:"ol"},"Add the container runtime information to the context so it can be used later:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"ctx = container.RuntimeInto(ctx, r.ContainerRuntime)\n")),(0,a.kt)("ol",{parentName:"li",start:3},(0,a.kt)("li",{parentName:"ol"},"Change this import ",(0,a.kt)("inlineCode",{parentName:"li"},'infrastructurev1alpha1 "github.com/capi-samples/cluster-api-provider-docker/api/v1alpha1"')," to ",(0,a.kt)("inlineCode",{parentName:"li"},'infrav1 "github.com/capi-samples/cluster-api-provider-docker/api/v1alpha1"')," and update the import name in ",(0,a.kt)("strong",{parentName:"li"},"SetupWithManager")," function.",(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},"The convention is to import your api with the major api version in the name only. The reason is when introducing a new api version you just update the import and not the import alias so as to reduce the number of code changes."))),(0,a.kt)("li",{parentName:"ol"},"Add the following imports:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'apierrors "k8s.io/apimachinery/pkg/api/errors"\n"k8s.io/klog/v2"\n\n"sigs.k8s.io/cluster-api/util"\n"sigs.k8s.io/cluster-api/util/annotations"\n"sigs.k8s.io/cluster-api/util/patch"\n\n"github.com/capi-samples/cluster-api-provider-docker/pkg/docker"\n')),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"You can delete the ",(0,a.kt)("inlineCode",{parentName:"li"},"// TODO(user): your logic here")," comment."),(0,a.kt)("li",{parentName:"ol"},"We need to get the instance of the ",(0,a.kt)("inlineCode",{parentName:"li"},"DockerCluster")," from the request. If the instance is not found exit reconciliation. Add the following:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"dockerCluster := &infrav1.DockerCluster{}\nif err := r.Client.Get(ctx, req.NamespacedName, dockerCluster); err != nil {\n    if apierrors.IsNotFound(err) {\n        return ctrl.Result{}, nil\n    }\n    return ctrl.Result{}, err\n}\n")),(0,a.kt)("ol",{parentName:"li",start:6},(0,a.kt)("li",{parentName:"ol"},"Next get the owning type of the ",(0,a.kt)("inlineCode",{parentName:"li"},"DockerCluster")," which is the CAPI ",(0,a.kt)("strong",{parentName:"li"},"Cluster"),". We can use a helper function from CAPI that will look at the ownerReferences. If it returns nil, we can requeue:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Get the Cluster\ncluster, err := util.GetOwnerCluster(ctx, r.Client, dockerCluster.ObjectMeta)\nif err != nil {\n    return ctrl.Result{}, err\n}\nif cluster == nil {\n    logger.Info("Waiting for Cluster Controller to set OwnerRef on DockerCluster")\n    return ctrl.Result{}, nil\n}\n')),(0,a.kt)("ol",{parentName:"li",start:7},(0,a.kt)("li",{parentName:"ol"},"Now we have the cluster we can update the logger to include the cluster name in later log lines:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'logger = logger.WithValues("cluster", klog.KObj(cluster))\nctx = ctrl.LoggerInto(ctx, logger)\n')),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},"You can add any name/value pairs that would aid in the support of your provider.")),(0,a.kt)("ol",{parentName:"li",start:8},(0,a.kt)("li",{parentName:"ol"},"Reconciliation can be paused, for instance when you pivot from an ephemeral bootstrap cluster to a permanent management cluster (i.e. via ",(0,a.kt)("a",{parentName:"li",href:"https://cluster-api.sigs.k8s.io/clusterctl/commands/move.html"},"clusterctl move"),"). We can check if the reconciliation is paused by looking for an annotation:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'if annotations.IsPaused(cluster, dockerCluster) {\n    logger.Info("DockerCluster or owning Cluster is marked as paused, not reconciling")\n\n    return ctrl.Result{}, nil\n}\n')),(0,a.kt)("ol",{parentName:"li",start:9},(0,a.kt)("li",{parentName:"ol"},"We will be using a helper to manage the lifecycle of the load balancer that will be created. So create a new instance of this:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Create a helper for managing a docker container hosting the loadbalancer.\nexternalLoadBalancer, err := docker.NewLoadBalancer(ctx, cluster, dockerCluster)\nif err != nil {\n    return ctrl.Result{}, errors.Wrapf(err, "failed to create helper for managing the externalLoadBalancer")\n}\n')),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},"Some providers follow a ",(0,a.kt)("strong",{parentName:"p"},"Scope & Services")," pattern. So instead of creating a loadbalancer helper they would create a ",(0,a.kt)("strong",{parentName:"p"},"Cluster Scope")," at this point which will hold everything that is required for reconciliation. If you are interested have a look at the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/kubernetes-sigs/cluster-api-provider-aws/blob/main/controllers/awscluster_controller.go#L181:L188"},"example from Cluster API Provider AWS"),"\n10. When we exit reconciliation, we want to persist any changes to ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," and this is done by using a patch helper:"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Initialize the patch helper\npatchHelper, err := patch.NewHelper(dockerCluster, r.Client)\nif err != nil {\n    return ctrl.Result{}, err\n}\n// Always attempt to Patch the DockerCluster object and status after each reconciliation.\ndefer func() {\n    if err := patchHelper.Patch(ctx, dockerCluster); err != nil {\n        logger.Error(err, "failed to patch DockerCluster")\n        if rerr == nil {\n            rerr = err\n        }\n    }\n}()\n')),(0,a.kt)("p",{parentName:"blockquote"},"If we were using conditions then we would need to set the condition values here as part of the patch.\n11. Now we are at the position of being able to do the actions that are specific to the Docker provider for create/update (i.e. ",(0,a.kt)("strong",{parentName:"p"},"reconcileNormal"),") and delete (i.e. ",(0,a.kt)("strong",{parentName:"p"},"reconcileDelete"),"). Replace ",(0,a.kt)("inlineCode",{parentName:"p"},"return ctrl.Result{}, nil")," with"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// Handle deleted clusters\nif !dockerCluster.DeletionTimestamp.IsZero() {\n    return r.reconcileDelete(ctx, dockerCluster, externalLoadBalancer)\n}\n"))),(0,a.kt)("p",{parentName:"li"},"// Handle non-deleted clusters\nreturn r.reconcileNormal(ctx, dockerCluster, externalLoadBalancer)"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"12. Add the following 2 empty functions:\n```go\nfunc (r *DockerClusterReconciler) reconcileNormal(ctx context.Context, dockerCluster *infrav1.DockerCluster, externalLoadBalancer *docker.LoadBalancer) (ctrl.Result, error) {\n    return ctrl.Result{}, nil\n}\n\nfunc (r *DockerClusterReconciler) reconcileDelete(ctx context.Context, dockerCluster *infrav1.DockerCluster, externalLoadBalancer *docker.LoadBalancer) (ctrl.Result, error) {\n    return ctrl.Result{}, nil\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"We are now ready to move onto implementing the create/update functionality."))),(0,a.kt)("h3",{id:"implement-createupdate-reconciliation"},"Implement create/update reconciliation"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We will continue to make changes in ",(0,a.kt)("inlineCode",{parentName:"li"},"controllers/dockercluster_controller.go"),"."),(0,a.kt)("li",{parentName:"ol"},"Add the following imports:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"\n"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"\n'))),(0,a.kt)("li",{parentName:"ol"},"Go to the ",(0,a.kt)("strong",{parentName:"li"},"reconcileNormal")," function."),(0,a.kt)("li",{parentName:"ol"},"Get the logger and log that we are reconciling for ",(0,a.kt)("strong",{parentName:"li"},"Docker Cluster"),":")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'logger := log.FromContext(ctx)\nlogger.Info("Reconciling DockerCluster")\n')),(0,a.kt)("ol",{start:5},(0,a.kt)("li",{parentName:"ol"},"We want to ensure that the finalizer for ",(0,a.kt)("inlineCode",{parentName:"li"},"DockerCluster")," is added so that if the ",(0,a.kt)("inlineCode",{parentName:"li"},"DockerCluster")," instance is deleted later on, we get the chance to do any required cleanup:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"if !controllerutil.ContainsFinalizer(dockerCluster, infrav1.ClusterFinalizer) {\n    controllerutil.AddFinalizer(dockerCluster, infrav1.ClusterFinalizer)\n\n    return ctrl.Result{Requeue: true}, nil\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"return ctrl.Result{Requeue: true}, nil"),". This means that after we have added the finalizer we will exit reconciliation and our ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," is patched. The ",(0,a.kt)("strong",{parentName:"p"},"Requeue: true")," will then cause the ",(0,a.kt)("strong",{parentName:"p"},"Reconciliation")," to be called again without the ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," instance being updated. This is a common pattern to ensure changes are persisted and as such its important to ensure your reconciliation logic is ",(0,a.kt)("strong",{parentName:"p"},"idempotent"),".\n6. Now we can create the load balancer container instances:"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Create the docker container hosting the load balancer if it does not exist.\nif err := externalLoadBalancer.Create(ctx); err != nil {\n    return ctrl.Result{}, errors.Wrap(err, "failed to create load balancer")\n}\n')),(0,a.kt)("ol",{parentName:"blockquote",start:7},(0,a.kt)("li",{parentName:"ol"},"Now get the IP address of the load balancer container:")),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Get the load balancer IP so we can use it for the enpoint address\nlbIP, err := externalLoadBalancer.IP(ctx)\nif err != nil {\n    return ctrl.Result{}, errors.Wrap(err, "failed to get IP for the load balancer")\n}\n')),(0,a.kt)("ol",{parentName:"blockquote",start:8},(0,a.kt)("li",{parentName:"ol"},"Use the ip address to set the endpoint for the control plane. This is required so that CAPI can use it when creating the kubeconfig for our cluster:")),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"dockerCluster.Spec.ControlPlaneEndpoint = clusterv1.APIEndpoint{\n    Host: lbIP,\n    Port: 6443,\n}\n")),(0,a.kt)("ol",{parentName:"blockquote",start:9},(0,a.kt)("li",{parentName:"ol"},"Finally set the ",(0,a.kt)("strong",{parentName:"li"},"Ready")," status property to true to indicate to CAPI that the infrastructure is ready and it can continue with creating the cluster:")),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"dockerCluster.Status.Ready = true\n")),(0,a.kt)("ol",{parentName:"blockquote",start:10},(0,a.kt)("li",{parentName:"ol"},"We can now move on to implementing deletion"))),(0,a.kt)("h3",{id:"implement-delete-reconciliation"},"Implement delete reconciliation"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We will continue to make changes in ",(0,a.kt)("inlineCode",{parentName:"li"},"controllers/dockercluster_controller.go"),"."),(0,a.kt)("li",{parentName:"ol"},"Go to the ",(0,a.kt)("inlineCode",{parentName:"li"},"reconcileDelete"),"."),(0,a.kt)("li",{parentName:"ol"},"Get the logger and log that we are reconciling for ",(0,a.kt)("strong",{parentName:"li"},"Docker Cluster"),":")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'logger := log.FromContext(ctx)\nlogger.Info("Reconciling DockerCluster deletion")\n')),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},"Delete any external infrastructure. For our provider, we need to delete the instance of the load balancer container:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// Delete the docker container hosting the load balancer\nif err := externalLoadBalancer.Delete(ctx); err != nil {\n    return ctrl.Result{}, errors.Wrap(err, "failed to delete load balancer")\n}\n')),(0,a.kt)("ol",{start:5},(0,a.kt)("li",{parentName:"ol"},"As all the external infrastructure is deleted we can remove the finalizer:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// Cluster is deleted so remove the finalizer.\ncontrollerutil.RemoveFinalizer(dockerCluster, infrav1.ClusterFinalizer)\n")),(0,a.kt)("h3",{id:"setup-the-controller"},"Setup the controller"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We need to tell ",(0,a.kt)("strong",{parentName:"li"},"controller-runtime")," what resources our controller should be reconciling. This is done within the ",(0,a.kt)("strong",{parentName:"li"},"SetupWithManager")," function."),(0,a.kt)("li",{parentName:"ol"},"Add the following imports:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'"sigs.k8s.io/controller-runtime/pkg/handler"\n"sigs.k8s.io/controller-runtime/pkg/source"\n\n"sigs.k8s.io/cluster-api/util/predicates"\n"github.com/capi-samples/cluster-api-provider-docker/pkg/container"\n')),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Change the signature of the ",(0,a.kt)("strong",{parentName:"li"},"SetupWithManager")," function so it accepts the context:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func (r *DockerClusterReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager) error\n")),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},"Delete the contents of the ",(0,a.kt)("strong",{parentName:"li"},"SetupWithManager")," function"),(0,a.kt)("li",{parentName:"ol"},"Add the following to the function:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"    c, err := ctrl.NewControllerManagedBy(mgr).\n        For(&infrav1.DockerCluster{}).\n        //WithOptions(options).\n        WithEventFilter(predicates.ResourceNotPaused(ctrl.LoggerFrom(ctx))).\n        Build(r)\n    if err != nil {\n        return err\n    }\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This tells controller runtime to call ",(0,a.kt)("strong",{parentName:"p"},"Reconcile")," when there is a change to ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster"),". Additionally you can add predicates (or event filters) to stop reconciliation occurring in certain situations. In this instance we use ",(0,a.kt)("inlineCode",{parentName:"p"},"WithEventFilter(predicates.ResourceNotPaused"),' to ensure reconciliation is not called when reconciliation is paused. You can also customize the settings of the "controller manager" by using ',(0,a.kt)("inlineCode",{parentName:"p"},"WithOptions(options)")," if needed, this often used to limit the number of concurrent reconciliations (although there will be at most one reconcile for a given instance).")),(0,a.kt)("ol",{start:6},(0,a.kt)("li",{parentName:"ol"},"In addition to the controller reconciling on changes to ",(0,a.kt)("inlineCode",{parentName:"li"},"DockerCluster")," we would also like it to happen if there are changes to its owning ",(0,a.kt)("strong",{parentName:"li"},"Cluster"),". Controller runtime allows you to watch a different resource type and then decide if you want to enqueue a request for reconciliation. Add the following:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'return c.Watch(\n    &source.Kind{Type: &clusterv1.Cluster{}},\n    handler.EnqueueRequestsFromMapFunc(util.ClusterToInfrastructureMapFunc(ctx, infrav1.GroupVersion.WithKind("DockerCluster"), mgr.GetClient(), &infrav1.DockerCluster{})),\n    predicates.ClusterUnpaused(ctrl.LoggerFrom(ctx)),\n)\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This is saying to watch ",(0,a.kt)("strong",{parentName:"p"},"clusterv1.Cluster")," and if there is a change to a ",(0,a.kt)("strong",{parentName:"p"},"Cluster")," instance, get the child ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," name/namespace using ",(0,a.kt)("inlineCode",{parentName:"p"},'util.ClusterToInfrastructureMapFunc(ctx, infrav1.GroupVersion.WithKind("DockerCluster"), mgr.GetClient(), &infrav1.DockerCluster{})')," and then use that name/namespace to enqueue a request for reconciliation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"DockerCluster")," instance with that name/namespace using ",(0,a.kt)("inlineCode",{parentName:"p"},"handler.EnqueueRequestsFromMapFunc"),". This will then result in ",(0,a.kt)("strong",{parentName:"p"},"Reconciliation")," being called.")),(0,a.kt)("ol",{start:7},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"As we have changed the parameters to ",(0,a.kt)("strong",{parentName:"p"},"SetupWithManager")," function, go to ",(0,a.kt)("inlineCode",{parentName:"p"},"main.go"),".")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"In the ",(0,a.kt)("strong",{parentName:"p"},"main")," function make these changes:"),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Add the following before we create the reconcilers:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'ctx := ctrl.SetupSignalHandler()\n// Set our runtime client into the context for later use\nruntimeClient, err := container.NewDockerClient()\nif err != nil {\n    setupLog.Error(err, "unable to establish container runtime connection", "controller", "reconciler")\n    os.Exit(1)\n}\n')),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},"This setups signal handlers so that the controllers can be gracefully terminated.")),(0,a.kt)("ol",{parentName:"li",start:2},(0,a.kt)("li",{parentName:"ol"},"Update the creation of ",(0,a.kt)("strong",{parentName:"li"},"DockerClusterReconciler")," to pass in the ",(0,a.kt)("strong",{parentName:"li"},"runtimeClient")," and the call to ",(0,a.kt)("strong",{parentName:"li"},"SetupWithManager")," on to pass in the context:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},'if err = (&controllers.DockerClusterReconciler{\n    Client:           mgr.GetClient(),\n    Scheme:           mgr.GetScheme(),\n    ContainerRuntime: runtimeClient,\n}).SetupWithManager(ctx, mgr); err != nil {\n    setupLog.Error(err, "unable to create controller", "controller", "DockerCluster")\n    os.Exit(1)\n}\n')),(0,a.kt)("ol",{parentName:"li",start:3},(0,a.kt)("li",{parentName:"ol"},"Change the ",(0,a.kt)("inlineCode",{parentName:"li"},"mgr.Start")," to use the context created earlier:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"if err := mgr.Start(ctx); err != nil {\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Ensure that all the api types are registered:"),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Add ",(0,a.kt)("inlineCode",{parentName:"li"},'clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"')," as an import in ",(0,a.kt)("inlineCode",{parentName:"li"},"main.go")," "),(0,a.kt)("li",{parentName:"ol"},"Add this api to the scheme by adding the following to ",(0,a.kt)("strong",{parentName:"li"},"init")," function:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-go"},"utilruntime.Must(clusterv1.AddToScheme(scheme))\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Run the following from a terminal:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"make manifests\nmake build\n")))}u.isMDXComponent=!0}}]);