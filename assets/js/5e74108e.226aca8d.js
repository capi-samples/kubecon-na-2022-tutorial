"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[112],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),p=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(a),d=r,k=m["".concat(i,".").concat(d)]||m[d]||u[d]||o;return a?n.createElement(k,l(l({ref:t},c),{},{components:a})):n.createElement(k,l({ref:t},c))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<o;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9302:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={},l="Cluster Templates",s={unversionedId:"templates",id:"templates",title:"Cluster Templates",description:"Objective: Create a cluster template and use that to test creation of a cluster.",source:"@site/docs/8-templates.md",sourceDirName:".",slug:"/templates",permalink:"/kubecon-na-2022-tutorial/docs/templates",draft:!1,editUrl:"https://github.com/capi-samples/kubecon-na-2022-tutorial/docs/8-templates.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Adding webhooks",permalink:"/kubecon-na-2022-tutorial/docs/webhooks"},next:{title:"Create a Cluster",permalink:"/kubecon-na-2022-tutorial/docs/create-cluster"}},i={},p=[{value:"Background",id:"background",level:2},{value:"Create the default template",id:"create-the-default-template",level:2},{value:"Test the template",id:"test-the-template",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cluster-templates"},"Cluster Templates"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Objective:")," Create a cluster template and use that to test creation of a cluster."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#cluster-templates"},"Cluster Templates"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-the-default-template"},"Create the default template")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#test-the-template"},"Test the template"))))),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,"Providers can supply templates (a.k.a flavors) that can be used to generate the manifests for a cluster. Templates must be in the ",(0,r.kt)("strong",{parentName:"p"},"templates")," folder of your providers repo. The default template will be in a file called ",(0,r.kt)("strong",{parentName:"p"},"cluster-template.yaml")," but you can created different named templates by naming the file using this format ",(0,r.kt)("strong",{parentName:"p"},"cluster-template-myname.yaml")," where ",(0,r.kt)("strong",{parentName:"p"},"myname")," can be anything you choose and that part becomes the template name. In this section we will be creating the default template."),(0,r.kt)("p",null,"Templates can contain contains, for example ",(0,r.kt)("strong",{parentName:"p"},"${CLUSTER_NAME}"),", and these tokens will be replaced by the value of an environment variable of the same name when you generate a clusters manifests using ",(0,r.kt)("strong",{parentName:"p"},"clusterctl"),". You also have the ability to set default values for a token should the environment variable not exist. "),(0,r.kt)("p",null,"CAPI uses a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/a8m/envsubst"},"specific version of envsubst")," internally and not the version you find on most linux systems."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You could also use ",(0,r.kt)("strong",{parentName:"p"},"ClusterClass")," to define a cluster template and then just change the required fields on a per cluster basis. This tutorial doesn't cover ClusterClass, so if you want to learn more please see the ",(0,r.kt)("a",{parentName:"p",href:"https://cluster-api.sigs.k8s.io/tasks/experimental-features/cluster-class/index.html"},"docs"),".")),(0,r.kt)("h2",{id:"create-the-default-template"},"Create the default template"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a folder called ",(0,r.kt)("strong",{parentName:"li"},"templates")," in the root of your repo."),(0,r.kt)("li",{parentName:"ol"},"Create a file called ",(0,r.kt)("strong",{parentName:"li"},"cluster-template.yaml")," in the ",(0,r.kt)("strong",{parentName:"li"},"templates")," folder")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you don't want to follow the individual steps in this section you can copy the contents of the template from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/capi-samples/cluster-api-provider-docker/blob/main/templates/cluster-template.yaml"},"here")," into your new ",(0,r.kt)("strong",{parentName:"p"},"cluster-template.yaml")," file.")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Add following steps will relate to adding to the new ",(0,r.kt)("strong",{parentName:"li"},"cluster-template.yaml")," file"),(0,r.kt)("li",{parentName:"ol"},"Add the definition for the root CAPI ",(0,r.kt)("strong",{parentName:"li"},"Cluster"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: cluster.x-k8s.io/v1beta1\nkind: Cluster\nmetadata:\n  name: "${CLUSTER_NAME}"\nspec:\n  clusterNetwork:\n    pods:\n      cidrBlocks:\n        - ${POD_CIDR:=172.25.0.0/16}\n    services:\n      cidrBlocks:\n        - ${SERVICES_CIDR:=172.26.0.0/16}\n  infrastructureRef:\n    apiVersion: infrastructure.cluster.x-k8s.io/v1alpha1\n    kind: DockerCluster\n    name: "${CLUSTER_NAME}"\n  controlPlaneRef:\n    kind: KubeadmControlPlane\n    apiVersion: controlplane.cluster.x-k8s.io/v1beta1\n    name: "${CLUSTER_NAME}-control-plane"\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The ",(0,r.kt)("strong",{parentName:"p"},"Cluster")," is the root and it will eventually own (via ",(0,r.kt)("inlineCode",{parentName:"p"},"ownerReference"),") all the other resource kins.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In this example you will see the use of a default value for a token: ",(0,r.kt)("inlineCode",{parentName:"p"},"${POD_CIDR:=172.25.0.0/16}"),". If there is no environment variable called ",(0,r.kt)("strong",{parentName:"p"},"POD_CIDR")," then the default value of ",(0,r.kt)("strong",{parentName:"p"},"172.25.0.0/16")," will be used. A list of the token options can be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/a8m/envsubst#docs"},"here"),".")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},"Now add our infrastructure specific representation of a cluster (i.er ",(0,r.kt)("strong",{parentName:"li"},"DockerCluster"),"):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: infrastructure.cluster.x-k8s.io/v1alpha1\nkind: DockerCluster\nmetadata:\n  name: "${CLUSTER_NAME}"\nspec: {}\n')),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},"To bootstrap the control plane nodes we will use the Kubeadm control plane provider (a.k.a ",(0,r.kt)("strong",{parentName:"li"},"KCP"),"):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\nkind: KubeadmControlPlane\napiVersion: controlplane.cluster.x-k8s.io/v1beta1\nmetadata:\n  name: "${CLUSTER_NAME}-control-plane"\nspec:\n  replicas: ${CONTROL_PLANE_MACHINE_COUNT}\n  version: "${KUBERNETES_VERSION:=v1.23.0}"\n  machineTemplate:\n    infrastructureRef:\n      kind: DockerMachineTemplate\n      apiVersion: infrastructure.cluster.x-k8s.io/v1alpha1\n      name: "${CLUSTER_NAME}-control-plane"\n  kubeadmConfigSpec:\n    initConfiguration:\n        nodeRegistration:\n            # We have to set the criSocket to containerd as kubeadm defaults to docker runtime if both containerd and docker sockets are found\n            criSocket: unix:///var/run/containerd/containerd.sock\n            kubeletExtraArgs:\n              cgroup-driver: cgroupfs\n              eviction-hard: nodefs.available<0%,nodefs.inodesFree<0%,imagefs.available<0%\n    clusterConfiguration:\n        controllerManager:\n            extraArgs: { enable-hostpath-provisioner: \'true\' }\n    joinConfiguration:\n        nodeRegistration:\n            # We have to set the criSocket to containerd as kubeadm defaults to docker runtime if both containerd and docker sockets are found\n            criSocket: unix:///var/run/containerd/containerd.sock\n            kubeletExtraArgs:\n              cgroup-driver: cgroupfs\n              eviction-hard: nodefs.available<0%,nodefs.inodesFree<0%,imagefs.available<0%\n')),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},"In our KCP definition there is a reference to an infrastructure specific machine template (i.e. ",(0,r.kt)("strong",{parentName:"li"},"DockerMachineTemplate"),") that will be used by KCP to create ",(0,r.kt)("strong",{parentName:"li"},"DockerMachine")," for our control planes. So we need to add this template:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\nkind: DockerMachineTemplate\napiVersion: infrastructure.cluster.x-k8s.io/v1alpha1\nmetadata:\n  name: "${CLUSTER_NAME}-control-plane"\nspec:\n  template:\n    spec: {}\n')),(0,r.kt)("ol",{start:8},(0,r.kt)("li",{parentName:"ol"},"The cluster and control plane have now been defined. Lets all a ",(0,r.kt)("strong",{parentName:"li"},"MachineDeployment")," for our clusters worker nodes:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: cluster.x-k8s.io/v1beta1\nkind: MachineDeployment\nmetadata:\n  name: "${CLUSTER_NAME}-md-0"\nspec:\n  clusterName: "${CLUSTER_NAME}"\n  replicas: ${WORKER_MACHINE_COUNT}\n  selector:\n    matchLabels:\n  template:\n    spec:\n      clusterName: "${CLUSTER_NAME}"\n      version: "${KUBERNETES_VERSION:=v1.23.0}"\n      bootstrap:\n        configRef:\n          name: "${CLUSTER_NAME}-md-0"\n          apiVersion: bootstrap.cluster.x-k8s.io/v1beta1\n          kind: KubeadmConfigTemplate\n      infrastructureRef:\n        name: "${CLUSTER_NAME}-md-0"\n        apiVersion: infrastructure.cluster.x-k8s.io/v1alpha1\n        kind: DockerMachineTemplate\n')),(0,r.kt)("ol",{start:9},(0,r.kt)("li",{parentName:"ol"},"A bit like the KCP definition the ",(0,r.kt)("strong",{parentName:"li"},"MachineDeployment")," holds a reference to the machine template to use for creating worker machines. Lets add that:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: infrastructure.cluster.x-k8s.io/v1alpha1\nkind: DockerMachineTemplate\nmetadata:\n  name: "${CLUSTER_NAME}-md-0"\nspec:\n  template:\n    spec: {}\n')),(0,r.kt)("ol",{start:10},(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("strong",{parentName:"li"},"MachineDeployment")," also contained a reference to the bootstrap provider to use when bootstrapping kubernetes on the infrastructure machines. The bootstrap provider normally matches the control plance provider, so in our case we need to use the Kubeadm bootstrap provider (a.k.a ",(0,r.kt)("strong",{parentName:"li"},"CAPBK"),"):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: bootstrap.cluster.x-k8s.io/v1beta1\nkind: KubeadmConfigTemplate\nmetadata:\n  name: "${CLUSTER_NAME}-md-0"\nspec:\n  template:\n    spec:\n      joinConfiguration:\n        nodeRegistration:\n          # We have to set the criSocket to containerd as kubeadm defaults to docker runtime if both containerd and docker sockets are found\n          criSocket: unix:///var/run/containerd/containerd.sock\n          kubeletExtraArgs:\n            cgroup-driver: cgroupfs\n            eviction-hard: nodefs.available<0%,nodefs.inodesFree<0%,imagefs.available<0%\n')),(0,r.kt)("h2",{id:"test-the-template"},"Test the template"),(0,r.kt)("p",null,"Now we have the template defined we can test it using clusterctl."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Open a new terminal and go to your providers repo."),(0,r.kt)("li",{parentName:"ol"},"Create environment variables with values for all the tokens in the template (that don't have a default values):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"export KUBERNETES_VERSION=v1.23.0\nexport CLUSTER_NAME=kubecontest\nexport CONTROL_PLANE_MACHINE_COUNT=1\nexport WORKER_MACHINE_COUNT=1\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Use ",(0,r.kt)("strong",{parentName:"li"},"clusterctl")," to generate the cluster definition:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"clusterctl generate cluster kubecontest --from templates/cluster-template.yaml\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This will output the generated cluster definition to stdout. You should see no tokens in the definition.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you have the kind cluster / tilt still running you can validate this template against the CRDs by saving to a file and running ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl apply -f cluster.yaml --dry-run=server"))))}u.isMDXComponent=!0}}]);